---
title: "Trait-based Comparative Transcriptomics Analysis"
author: "Joris van Steenbrugge & Ben Oyserman"
date: "August 23, 2017"
output: html_document
---
```{r,results='hide'}
library(TbasCO)
library(magrittr)

```
#Loading and Preprocessing Data


All of the preprocessing is handled by the `Pre_process_input` function.
This function consequtively performs the following tasks:

1. Data Loading
2. Normalization
3. Filtering


### Data loading
The data set should contain the following Elements:

* A column named **Gene**
* Multiple expression data columns that have at least the word **Sample** in it
* A column named **Annotation**
* A column named **Bin**

Additional columns may be present but are not used in the analysis.
Loading of data is done by assigning a file.path to the function's `filepath`
variable.


## Databases
```{r}
load(file = 'data/kegg_module_2019_07_23.RData"')
database <- Combine_databases(kegg_brite_20191208, kegg_module_20190723)

```



### Normalization
The package supports different options for normalization. By default the `Pre_process_input` function
does not normalize the data. To indicate if normalization should be performed, the function parameter 
`normalize.var` may be used. The variable can either be left out, set to 'default', or to a custom user-defined function.
```{r Preprocessing}
normalization.features <- list('no_feature'   = c(9159700, 4459877, 9826273, 8171512, 9542765, 10522313),
                  'ambiguous'    = c(3940698, 2023389, 4675033, 3308789, 6446272, 5966543),
                  'library_size' = c(234232896, 183166236, 228746720, 198024002, 231567992, 259156166),
                  'not_aligned'  = c(0, 0, 0, 0, 0, 0)
                  )

normalization.features <- c(234232896, 183166236, 228746720, 198024002, 231567992, 259156166)


RNAseq.data <- Pre_process_input(file.path,
                                 database = database,
                                 normalize.method    = F,
                                 normalization.features = NULL,
                                 filter.method       = F,
                                 filter.low.coverage = F)


# Phylum: Run this for Ben's dataset
genome.taxonomy.phylum <- list('8'  = 'p__Bacteroidetes',
                         '11' = 'p__Proteobacteria',
                         '16' = 'p__Proteobacteria',
                         '17' = '.',
                         '19' = 'p__Bacteroidetes',
                         '20' = '.',
                         '22' = 'p__Proteobacteria',
                         '25' = 'p__Bacteroidetes',
                         '26' = 'p__Actinobacteria',
                         '28' = 'p__Bacteroidetes',
                         '29' = 'p__Proteobacteria',
                         '31' = 'p__Proteobacteria',
                         '32' = 'p__Proteobacteria',
                         '36' = 'p__Actinobacteria',
                         '39' = 'p__Proteobacteria',
                         '42' = 'p__Bacteroidetes',
                         '45' = 'p__Bacteroidetes',
                         '48' = 'p__Proteobacteria',
                         '53' = 'p__Bacteroidetes'
                         )
# Phylum: Run this for Elizabeth's dataset
genome.taxonomy.phylum <- list("3300026302-bin.46" = "p__Proteobacteria",
                               "3300026282-bin.4"  = "p__Proteobacteria",
                               "3300026302-bin.32" = "p__Bacteroidota",
                               "3300009517-bin.31" = "p__Bacteroidota",
                               "3300026288-bin.43" = "p__Actinobacteriota",
                               "3300009517-bin.6"  = "p__Proteobacteria",
                               "3300026303-bin.42" = "p__Bacteroidota",
                               "3300009517-bin.1"  = "p__Bacteroidota",
                               "3300009517-bin.42" = "p__Proteobacteria",
                               "3300026284-bin.9"  = "p__Proteobacteria",
                               "3300026302-bin.62" = "p__Cyanobacteriota",
                               "3300009517-bin.3"  = "p__Bacteroidota",
                               "3300009517-bin.47" = "p__Proteobacteria",
                               "3300009517-bin.13" = "p__Proteobacteria",
                               "3300009517-bin.12" = "p__Bacteroidota",
                               "3300026302-bin.10" = "p__Proteobacteria"
                               )

# genome.taxonomy.family <- list('8'  = 'f_Cytophagaceae',
#                          '11' = 'f__Rubrivivax',
#                          '16' = 'f_Rhodocyclaceae',
#                          '17' = '.',
#                          '19' = 'f_Cytophagaceae',
#                          '20' = '.',
#                          '22' = 'f_Comamonadaceae',
#                          '25' = 'f_Chitinophagaceae',
#                          '26' = 'o_Actinomycetales',
#                          '28' = 'p_bacteroidetes',
#                          '29' = 'f_Comamonadaceae',
#                          '31' = 'f_Rhodobacteraceae',
#                          '32' = 'f_Xanthomonadaceae',
#                          '36' = 'o_Actinomycetales',
#                          '39' = 'f_Rhodocyclaceae',
#                          '42' = 'p_Bacteroidetes',
#                          '45' = 'f_Flavobacteriaceae',
#                          '48' = 'c_Alphaproteobacteria',
#                          '53' = 'f_Flavobacteriaceae'
#                          )

```

### Define the distance metrics to be used
In this vignette, the Pearson Correlation and the Normalized Rank Euclidean Distance are used.
The user is free to implement different metrics, as long as the function parameters
are identical to the ones in the example PC and NRED functions.
In these examples, rowA and rowB are rows from RNAseq.data$table.
```{r Defining Distance Metrics}
# Calculates the Pearson Correlation
PC <- function(rowA, rowB, RNAseq.features){
  return(cor(as.numeric(rowA[RNAseq.features$sample.columns]),
             as.numeric(rowB[RNAseq.features$sample.columns])
             )
         )
}

# Calculates the Normalized Rank Euclidean Distance
NRED <- function(rowA, rowB, RNAseq.features) {
  r.A <- as.numeric(rowA[ RNAseq.features$rank.columns ])
  r.B <- as.numeric(rowB[ RNAseq.features$rank.columns ])
  return(
    sum((r.A - r.B) * (r.A - r.B))
  )
}

# Combine multiple distance metrics to complement each other.
distance.metrics <- list("NRED" = NRED,
                         "PC"   = PC)

# the size of all modules in the library, usefull for calculating the background distribution
module_size_range <- lapply(RNAseq.data$features$annotation.db$module.dict,length) %>% as.numeric() %>% table() %>% names() %>% as.numeric()

# again, the size of all modules but using the maximum length of the disjunctive form. Slightly shorter
d_module_size_range_all<-c()
for (i in 1:length(sub_modules)) {
  d_module_size_range_all[i]<- max(sapply(sub_modules[[i]],length))
}
d_module_size_range<-sort(unique(d_module_size_range_all))


```

### Actual Analysis
```{r Main Analysis}
bkgd.individual         <- Individual_Annotation_Background(RNAseq.data, 
                                                            N       = 10000, 
                                                            metrics = distance.metrics,
                                                            threads = 3)

bkgd.individual.Zscores <- Calc_Z_scores(bkgd.individual, distance.metrics)

bkgd.traits             <- Random_Trait_Background(RNAseq.data, 
                                                   bkgd.individual.Zscores,
                                                   N = 10000, 
                                                   metrics = distance.metrics,
                                                   threads = 3)

start <- Sys.time()
pairwise.distances      <- Calc_Pairwise_Annotation_Distance(RNAseq.data,
                                                             RNAseq.data$features$annotation.db,
                                                             distance.metrics,
                                                             bkgd.individual.Zscores,
                                                             show.progress = F,
                                                             threads = 3)
end <- Sys.time()
print(end-start)

trait.attributes        <- Identify_Trait_Attributes(RNAseq.data = RNAseq.data, 
                                                     pairwise.distances = pairwise.distances,
                                                     threads = 2)

trait.attributes.pruned <- Prune_Trait_Attributes(trait.attributes, bkgd.traits, 
                                                  RNAseq.data,
                                                  p.threshold = 0.05,
                                                  pairwise.distances = pairwise.distances,
                                                  bkgd.individual.Zscores = bkgd.individual.Zscores)

sbs.trait.attributes    <- Traitattributes_To_Sbsmatrix(trait.attributes.pruned, 
                                                        RNAseq.data$features$bins)
```

### Plot background of individual genes
```{r bunch_o_figs, fig.height=8, fig.width=12}
Plot_Background_Individual_Genes(bkgd.individual.Zscores)

Plot_Metric_Comparison(bkgd.individual)
Plot_Redundancy_Traits(RNAseq.data)
```

### Plot background of individual genes
```{r bunch_o_figs, fig.height=8, fig.width=12}
Plot_Background_Modules(bkgd.traits)

```


### Model_Module Figure
```{r bunch_o_figs, fig.height=8, fig.width=12}
Module_Names <- RNAseq.data$features$trait_presence_absence[,'3300026284-bin.9'] %>% which(. == T) %>% names
margins =c(5,23)
Model_Module_List_All <- Model_Module(RNAseq.data, trait.attributes, 39, Module_Names, bkgd.traits)
Plot_Model_Module(Model_Module_List_All, 39, Module_Names, margins, sortbygenome="3300026282-bin.4")

```

### Figures of functional redundancy and linear regression
```{r bunch_o_figs, fig.height=8, fig.width=8}

TnA_redundancy <- Calc_TnA_redundancy(RNAseq.data)

# Sort based on attributes
Most_redundant_order <- TnA_redundancy[order(TnA_redundancy[,3]),1]



# Color by taxonomy
stc<- string.to.colors(genome.taxonomy.phylum)
# Color by taxonomy in the order based on redundancy
stc_highlights <- stc[match(rev(Most_redundant_order),names(stc))]

par(mfrow=c(4,5),mar=c(2,2,2,2))
#Plot_traits_vs_attributes()


#Figure 2-E
plot(as.numeric(TnA_redundancy[,3])~as.numeric(TnA_redundancy[,2]), col=stc, xlim=c(500,1100), ylim=c(100,400), pch = 19, xlab = "Attributes", ylab = "Traits")

# For some reason, legend is providing error
#legend(x=500, y=400, legend= c("Bacteroidetes","Proteobacteria", "Bacteria","Actinobacteria"), pch=19, col = unique(stc_highlights), cex=0.5)

as.numeric(Most_redundant_order)
j= 1
for (i in rev(Most_redundant_order)) {
  Plot_traits_vs_attributes_highlight(i,stc_highlights[j])
  j = j+1
}


```


Figure 2 C&D
```{r}
module_categories <- Get_module_categories(kegg_categories_script)
a <- getMetricDistModule(metric = 'PC', module_categories)
```


## Apriori
```{r}

rules <- Association_Rules(sbs.trait.attributes, N = 30,
                           rhs= c('PHA.1', 'PHA.2'))

Network_Association_Rules(as(rules, 'data.frame'),annotation.db = RNAseq.data$features$annotation.db,
             N = 30)
```


## Experimental
```{r}
Go_Fish(RNAseq.data)
# Retrieving all M00009 attributes
M00009 <- names(trait.attributes.pruned) %>% grep("M00009", .)
M00009_attributes <- trait.attributes.pruned[M00009] %>% 
                          sapply(length) %>% `!=` (0) %>% which %>% names

trait.attributes.pruned[M00009_attributes]
```

## Publication figure creating
```{r}
Plot_Categories()
```
